# 排序

## 排序算法优劣主要从下面3点来比较

> 1. 时间复杂度，包括最好、最坏、平均时间复杂度，数据规模不大的情况下，需要进一步比较系数、低阶、常数
> 2. 空间复杂度，是否原地排序
> 3. 稳定性，同样的值排序后是否会改变原来的相对顺序

## O(n2)

| | | 冒泡 | 插入 | 选择
|---|---|---|---|---
|效率|最好|O(n)|O(n)|O(n2)
||最坏|O(n2)|O(n2)|O(n2)
||平均|O(n2)|O(n2)|O(n2)
|in-place||Y|Y|Y
|稳定||Y|Y|Y

### 冒泡排序

> 两两比较，如果前者大则交换顺序。最大值被移动到最后
> 重复上述过程，直到所有值都被两两比较过

``` python
    # array based
    def bubble_sort(array: [int]):
        if len(array) == 0 or len(array) == 1:
            return
        
        for i in range(len(array)):
            changed = False
            for j in range(0, len(array)-i-1):
                if array[j] > array[j+1]:
                    array[i], array[j+1] = array[j+1], array[j]
                    changed = True
            if not changed:
                break

    # linked list based
    def buddle_sort(head: Optional[ListNode]) -> Optional[ListNode]:
    if not head:
        return
    dummy = ListNode(next=head)
    tail = None
    while dummy.next != tail:
        pre = dummy
        cur = dummy.next
        swapped = False
        while cur.next != tail:
            if cur.val > cur.next.val:
                next = cur.next
                cur.next = next.next
                next.next = cur
                pre.next = next
                pre = pre.next
                swapped = True
            else:
                cur = cur.next
                pre = pre.next
        tail = cur
        if not swapped:
            break
    
    return dummy.next
```

### 插入排序

> 分为已排序区和未排序区，每次从未排序区取一个元素插入到已排序区，直到未排序区没有数据

``` python
    # array based
    def insert_sort(array:Optional[int]):
        if len(array) == 0 or len(array) == 1:
            return
        for i in range(1, len(array)):
            value = array[i]
            j = i
            while j > 0 and array[j-1] > value:
                array[j] = array[j-1]
                j -= 1
            array[j] = value

    # linked list based
    def insert_sort(head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        dummy = ListNode(next=head)
        
        tail = head
        cur = head.next
        while cur:
            if tail.val <= cur.val:
                tail = cur
            else:
                prev = dummy
                while prev.next and prev.next <= cur.next:
                    prev = prev.next
                
                tail.next = cur.next
                cur.next = prev.next
                prev.next = cur
            
            cur = tail.next
        return dummy.next
```

### 选择排序

> 分为已排序区和未排序区，每次从未排序区选出最小值放到已排序区最后，直到未排序区没有数据

```python
    # array based
    def selection_sort(array: Optional[int]):
        if len(array) == 0 or len(array) == 1:
            return
        for i in range(len(array)-1):
            min_value = array[i]
            for j in range(i+1, len(array)):
                if array[j] < min_value:
                    min_value, array[i], array[j] = array[j], array[j], min_value
    
    # linked list based
    def selection_sort(head: Optional[ListNode]) -> Optional[ListNode]:
        """ not in-place implement"""
        dummy = ListNode(next = head)
        result = cur = ListNode()
        
        while dummy.next:
            p = dummy
            i = j = dummy.next
            min_value = i.val
            while j.next:
                if j.next.val < min_value:
                    min_value = j.next.val
                    p = j
                j = j.next
            
            node = p.next
            p.next = p.next.next
            node.next = None
            cur.next = node
            cur = cur.next

        return result.next
    

    def selection_sort(head: Optional[ListNode]) -> Optional[ListNode]:
        """ in-place implement """
        dummy = ListNode(next=head)

        p1 = dummy
        while p1.next:
            i = j = p2 = p1.next
            min_value = i
            while j.next:
                if j.next.val < min_value.val:
                    min_value = j.next
                    p2 = j
                j = j.next
            
            if i != min_value:
                k = p2.next
                p1.next, p2.next = k, i
                i.next, k.next = k.next, i.next
            
            p1 = p1.next
        
        return dummy.next
```

### 希尔排序

## O(nlogn)

|||归并|快速
|---|---|---|---
|性能|最好|O(nlogn)|O(nlogn)
||最坏|O(nlogn)|O(n2)
||平均|O(nlogn)|O(nlogn)
|in-place||N|Y
|稳定||Y|N

### 归并排序

> 把数据一份为二，直到不可分为止；把两部分数据合并排序，直到所有数据都排序

``` python
    def merge_sort(array:Optional[int]) -> Optional[int]:
        if len(array) == 0 or len(array) == 1:
            return array
        q = len(array) // 2
        
        # spilt
        left = merge_sort(array[:q])
        right = merge_sort(array[q:])

        # merge
        tmp = [None] * (len(left) + len(right))
        left.append(sys.maxsize)
        right.append(sys.maxsize)
        i = j = 0
        for k in range(len(tmp)):
            if left[i] < right[j]:
                tmp[k] = left[i]
                i += 1
            else:
                tmp[k] = right[j]
                j += 1
        return tmp
```

### 快速排序

> 选择一个支点（pivot），把数据分为小于pivot和大于等于pivot两个区；继续对这两个分区重复操作，直到每个区里的数据个数小于或等于1

```python
    def quick_sort(array:Optional[int]):

        def _partition(array, start, end):
            pivot = array[end]
            i = 0
            for j in range(0, end):
                if array[j] < pivot:
                    array[i], array[j] = array[j], array[i]
                    i += 1
            array[i], array[end] = array[end], array[i]
            return i

        def _quick_sort(array:Optional[int], start: Optional[int], end: Optional[int]):
            if start >= end:
                return
            p = _partition(array, start, end)
            _quick_sort(array, start, p-1)
            _quick_sort(array, p, end)    

        _quick_sort(array, 0, len(array)-1)
```

### 堆排序
