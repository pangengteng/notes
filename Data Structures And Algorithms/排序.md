# 排序

## 排序算法优劣主要从下面3点来比较

> 1. 时间复杂度，包括最好、最坏、平均时间复杂度，数据规模不大的情况下，需要进一步比较系数、低阶、常数
> 2. 空间复杂度，是否原地排序
> 3. 稳定性，同样的值排序后是否会改变原来的相对顺序

## O(n2)
| | | 冒泡 | 插入 | 选择｜
|---|---|---|---|---|
|效率|最好|O(n)|O(n)|O(n2)
||最坏|O(n2)|O(n2)|O(n2)
||平均|O(n2)|O(n2)|O(n2)
|in-place||Y|Y|Y
|稳定||Y|Y|Y

## 原理 & 实现

### 冒泡排序

> 两两比较，如果前者大则交换顺序。最大值被移动到最后
> 重复上述过程，直到所有值都被两两比较过

``` python
    # array based
    def bubbleSort(array: [int]):
        if len(array) == 0 or len(array) == 1:
            return
        
        for i in range(len(array)):
            changed = False
            for j in range(0, len(array)-i-1):
                if array[j] > array[j+1]:
                    array[i], array[j+1] = array[j+1], array[j]
                    changed = True
            if not changed:
                break

    # linked list based
    def buddleSort(head: Optional[ListNode]) -> Optional[ListNode]:
    if not head:
        return
    dummy = ListNode(next=head)
    tail = None
    while dummy.next != tail:
        pre = dummy
        cur = dummy.next
        swapped = False
        while cur.next != tail:
            if cur.val > cur.next.val:
                next = cur.next
                cur.next = next.next
                next.next = cur
                pre.next = next
                pre = pre.next
                swapped = True
            else:
                cur = cur.next
                pre = pre.next
        tail = cur
        if not swapped:
            break
    
    return dummy.next
```

### 插入排序

> 分为已排序区和未排序区，每次从未排序区取一个元素插入到已排序区，直到未排序区没有数据

``` python
    # array based
    def insertSort(array:Optional[int]):
        if len(array) == 0 or len(array) == 1:
            return
        for i in range(1, len(array)):
            value = array[i]
            j = i
            while j > 0 and array[j-1] > value:
                array[j] = array[j-1]
                j -= 1
            array[j] = value

    # linked list based
    def insertSort(head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        dummy = ListNode(next=head)
        
        tail = head
        cur = head.next
        while cur:
            if tail.val <= cur.val:
                tail = cur
            else:
                prev = dummy
                while prev.next and prev.next <= cur.next:
                    prev = prev.next
                
                tail.next = cur.next
                cur.next = prev.next
                prev.next = cur
            
            cur = tail.next
        return dummy.next
```

### 选择排序