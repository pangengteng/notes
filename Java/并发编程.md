# 并发编程
> 可以抽象成三个问题：分工、同步、互斥
> 分工：把一个大任务分解成多个子任务。关注执行效率
> 同步：任务之间有依赖。当一个任务不满足执行条件时，需要等待，当任务满足执行条件时，需要被触发执行。关注执行效率
> 互斥：保证多个任务正确的访问同一个资源。关注的是（线程）安全

## 并发是为了提升性能
> 计算机体系结构（硬件）：CPU缓存，平衡CPU和内存的速度差异
> 操作系统（软件）：多进程、线程，分时复用CPU，平衡CPU和IO的速度差异
> 编译器（开发语言）：指令重排

> 解决问题的同时也引入了一些问题
> CPU缓存：可见性
> 线程切换：原子性
> 指令重排：有序性

> [并发编程01](https://time.geekbang.org/column/article/83682)


## 如何解决可见性和有序性
> Java 内存规范了如何按需禁用缓存和编译优化的方法，包括volatile, synchronized, final关键字，6个Happens-Before原则。
> Java 内存模型：一套复杂的规范。从程序员角度看，关注并发编程相关部分，核心是Happens-Before原则。

> 6个Happens-Before原则
> 1. 程序的顺序性
> 2. volatile 规则: 对volatile变量的写操作，对后续的读操作可见
> 3. 传递性: 如果A Before B, B before C, 那么A Before C
> 4. 锁的规则：对 synchronized 的解锁 Before 于对 synchronized 的加锁
> 5. 线程 start() 方法：主线程A启动子线程B后，子线程能够看到启动前的操作
> 6. 线程 join() 方法：子线程的操作，对主线程调用子线程的join()方法后可见